##
# IP: GHIDRA
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##
# Malware Analyzer Script
# @category: Examples.Python
# @runtime PyGhidra

import typing
if typing.TYPE_CHECKING:
    from ghidra.ghidra_builtins import *

import os
import time
import json
import re
from datetime import datetime
from javax.swing import JFrame
from javax.swing import JPanel
from javax.swing import JButton
from javax.swing import JComboBox
from javax.swing import JTextField
from javax.swing import JTextArea
from javax.swing import JScrollPane
from javax.swing import JLabel
from javax.swing import JTabbedPane
from javax.swing import BoxLayout
from javax.swing import BorderFactory
from javax.swing import JOptionPane
from javax.swing import JCheckBox
from javax.swing import JSeparator
from javax.swing import JList
from javax.swing import DefaultListModel
from javax.swing import ListSelectionModel
from javax.swing import JTable
from javax.swing import DefaultTableModel
from javax.swing import JProgressBar
from javax.swing import JFileChooser
from javax.swing.filechooser import FileNameExtensionFilter
from javax.swing import JDialog
from javax.swing import JToolBar
from java.awt import BorderLayout
from java.awt import FlowLayout
from java.awt import GridLayout
from java.awt import Dimension
from java.awt.event import ActionListener
from java.awt.event import ActionEvent
from java.io import File
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.app.services import AnalysisManager
from ghidra.app.services import AnalysisService
from ghidra.app.util import OptionDialog
from ghidra.program.model.address import Address
from ghidra.program.model.address import AddressSet
from ghidra.program.model.listing import Function
from ghidra.program.model.listing import CodeUnit
from ghidra.program.model.listing import Instruction
from ghidra.program.model.symbol import Symbol
from ghidra.program.model.symbol import SymbolType
from ghidra.program.model.symbol import SourceType
from ghidra.app.script import GhidraScriptUtil
from ghidra.app.util.exporter import Exporter
from ghidra.app.util.exporter import ExporterUtilities
from ghidra.framework.model import DomainFile
from ghidra.framework.model import ProjectData
from ghidra.framework.project import ProjectLocator
from ghidra.framework import Application
from ghidra.util import FileUtilities


# Malware signatures database
MALWARE_SIGNATURES = {
    "ransomware": {
        "name": "Ransomware",
        "description": "Malware that encrypts user data and demands payment",
        "signatures": [
            "encrypt", "decrypt", "ransom", "wallet", "bitcoin", "monero",
            "payment", "decryptor", "key", "cipher", "crypt", "victim"
        ],
        "behaviors": [
            "file_encryption", "ransom_note", "wallet_address", "network_connection"
        ]
    },
    "trojan": {
        "name": "Trojan Horse",
        "description": "Malware that disguises itself as legitimate software",
        "signatures": [
            "remote", "access", "control", "backdoor", "shell", "command",
            "execute", "inject", "payload", "download", "upload"
        ],
        "behaviors": [
            "remote_access", "command_execution", "file_download", "persistence"
        ]
    },
    "virus": {
        "name": "Virus",
        "description": "Malware that replicates itself and infects other files",
        "signatures": [
            "infect", "replicate", "copy", "spread", "inject", "attach",
            "execute", "boot", "sector"
        ],
        "behaviors": [
            "self_replication", "file_infection", "boot_sector_modification"
        ]
    },
    "worm": {
        "name": "Worm",
        "description": "Malware that self-replicates and spreads over networks",
        "signatures": [
            "network", "spread", "replicate", "scan", "connect", "transfer",
            "copy", "propagate"
        ],
        "behaviors": [
            "network_scanning", "self_propagation", "remote_exploitation"
        ]
    },
    "spyware": {
        "name": "Spyware",
        "description": "Malware that collects user information without consent",
        "signatures": [
            "keylog", "capture", "screen", "log", "record", "monitor",
            "steal", "data", "password", "credit", "card", "info"
        ],
        "behaviors": [
            "keylogging", "screen_capture", "data_exfiltration", "password_stealing"
        ]
    },
    "adware": {
        "name": "Adware",
        "description": "Malware that displays unwanted advertisements",
        "signatures": [
            "ad", "advertisement", "popup", "banner", "click", "redirect",
            "marketing", "promotion"
        ],
        "behaviors": [
            "unwanted_ads", "browser_redirect", "click_fraud"
        ]
    },
    "rootkit": {
        "name": "Rootkit",
        "description": "Malware that provides privileged access to a computer",
        "signatures": [
            "root", "kit", "hide", "conceal", "privilege", "access",
            "kernel", "module", "driver"
        ],
        "behaviors": [
            "privilege_escalation", "process_hiding", "file_hiding", "persistence"
        ]
    },
    "keylogger": {
        "name": "Keylogger",
        "description": "Malware that records keystrokes",
        "signatures": [
            "keylog", "key", "log", "record", "capture", "stroke",
            "keyboard", "input"
        ],
        "behaviors": [
            "keystroke_logging", "data_exfiltration", "password_stealing"
        ]
    },
    "botnet": {
        "name": "Botnet",
        "description": "Network of compromised computers controlled by a server",
        "signatures": [
            "bot", "net", "command", "control", "c&c", "server",
            "connect", "network", "join", "register"
        ],
        "behaviors": [
            "c2_communication", "remote_control", "ddos_attack", "spam"
        ]
    },
    "exploit": {
        "name": "Exploit",
        "description": "Malware that takes advantage of vulnerabilities",
        "signatures": [
            "exploit", "vulnerability", "buffer", "overflow", "stack",
            "heap", "payload", "shellcode", "inject"
        ],
        "behaviors": [
            "vulnerability_exploitation", "code_injection", "privilege_escalation"
        ]
    }
}

# API signatures for suspicious activities
SUSPICIOUS_APIS = {
    "file_operations": [
        "CreateFile", "WriteFile", "ReadFile", "DeleteFile", "MoveFile",
        "CopyFile", "FindFirstFile", "FindNextFile", "GetFileAttributes"
    ],
    "network_operations": [
        "socket", "connect", "send", "recv", "listen", "accept",
        "WSAStartup", "WSASocket", "InternetOpen", "InternetConnect"
    ],
    "process_operations": [
        "CreateProcess", "OpenProcess", "TerminateProcess", "CreateThread",
        "ResumeThread", "SuspendThread", "GetProcessHandle"
    ],
    "registry_operations": [
        "RegOpenKey", "RegCreateKey", "RegSetValue", "RegDeleteKey",
        "RegQueryValue", "RegCloseKey"
    ],
    "memory_operations": [
        "VirtualAlloc", "VirtualFree", "VirtualProtect", "ReadProcessMemory",
        "WriteProcessMemory", "HeapAlloc", "HeapFree"
    ],
    "system_operations": [
        "GetSystemDirectory", "GetWindowsDirectory", "SetWindowsHookEx",
        "SetThreadContext", "CreateRemoteThread", "InjectLibrary"
    ]
}


def show_malware_analyzer():
    """Show malware analyzer UI"""
    
    print("=== Malware Analyzer ===")
    
    # Create the main frame
    frame = create_main_frame()
    frame.setVisible(True)


def create_main_frame():
    """Create the main malware analyzer frame"""
    
    # Create frame
    frame = JFrame("Malware Analyzer")
    frame.setSize(1100, 700)
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE)
    frame.setLayout(BorderLayout())
    
    # Create tabbed pane for different malware analysis tools
    tabbed_pane = JTabbedPane()
    
    # Add tabs
    tabbed_pane.addTab("Malware Detection", create_malware_detection_panel())
    tabbed_pane.addTab("Behavior Analysis", create_behavior_analysis_panel())
    tabbed_pane.addTab("Signature Scanner", create_signature_scanner_panel())
    tabbed_pane.addTab("API Usage Analysis", create_api_usage_panel())
    tabbed_pane.addTab("Results", create_malware_results_panel())
    
    # Add status bar
    status_bar = JPanel(FlowLayout(FlowLayout.LEFT))
    status_label = JLabel(f"Program: {currentProgram.name if currentProgram else 'No Program Open'}")
    status_bar.add(status_label)
    
    # Add components to frame
    frame.add(tabbed_pane, BorderLayout.CENTER)
    frame.add(status_bar, BorderLayout.SOUTH)
    
    return frame


def create_malware_detection_panel():
    """Create panel for malware detection"""
    
    panel = JPanel(BorderLayout())
    panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10))
    
    # Top panel with detection options
    top_panel = JPanel()
    top_panel.setLayout(BoxLayout(top_panel, BoxLayout.Y_AXIS))
    
    # Detection options
    options_panel = JPanel(FlowLayout(FlowLayout.LEFT))
    options_panel.setBorder(BorderFactory.createTitledBorder("Detection Options"))
    
    quick_scan_button = JButton("Quick Scan")
    full_scan_button = JButton("Full Scan")
    custom_scan_button = JButton("Custom Scan")
    
    options_panel.add(quick_scan_button)
    options_panel.add(full_scan_button)
    options_panel.add(custom_scan_button)
    
    # Malware types to scan for
    types_panel = JPanel(BorderLayout())
    types_panel.setBorder(BorderFactory.createTitledBorder("Malware Types to Scan For"))
    
    types_grid = JPanel(GridLayout(3, 3))
    malware_type_checkboxes = {}
    
    for malware_type, info in MALWARE_SIGNATURES.items():
        checkbox = JCheckBox(info["name"])
        checkbox.setSelected(True)
        malware_type_checkboxes[malware_type] = checkbox
        types_grid.add(checkbox)
    
    types_panel.add(types_grid, BorderLayout.CENTER)
    
    # Scan options
    scan_options_panel = JPanel(FlowLayout(FlowLayout.LEFT))
    scan_options_panel.setBorder(BorderFactory.createTitledBorder("Scan Options"))
    
    include_strings_checkbox = JCheckBox("Include String Analysis")
    include_strings_checkbox.setSelected(True)
    include_apis_checkbox = JCheckBox("Include API Analysis")
    include_apis_checkbox.setSelected(True)
    include_behavior_checkbox = JCheckBox("Include Behavior Analysis")
    include_behavior_checkbox.setSelected(True)
    
    scan_options_panel.add(include_strings_checkbox)
    scan_options_panel.add(include_apis_checkbox)
    scan_options_panel.add(include_behavior_checkbox)
    
    # Execution options
    execution_panel = JPanel(FlowLayout(FlowLayout.LEFT))
    execute_button = JButton("Execute Malware Scan")
    execute_button.setPreferredSize(Dimension(200, 30))
    execution_panel.add(execute_button)
    
    # Bottom panel with status
    bottom_panel = JPanel(BorderLayout())
    status_area = JTextArea()
    status_area.setEditable(False)
    status_area.setLineWrap(True)
    status_area.setWrapStyleWord(True)
    status_scroll = JScrollPane(status_area)
    status_scroll.setPreferredSize(Dimension(800, 100))
    
    bottom_panel.add(status_scroll, BorderLayout.CENTER)
    
    top_panel.add(options_panel)
    top_panel.add(types_panel)
    top_panel.add(scan_options_panel)
    top_panel.add(execution_panel)
    
    # Add components to panel
    panel.add(top_panel, BorderLayout.NORTH)
    panel.add(bottom_panel, BorderLayout.SOUTH)
    
    # Add action listeners
    class ButtonActionListener(ActionListener):
        def actionPerformed(self, event):
            if event.getSource() == quick_scan_button:
                perform_quick_scan(malware_type_checkboxes, status_area)
            elif event.getSource() == full_scan_button:
                perform_full_scan(malware_type_checkboxes, status_area)
            elif event.getSource() == custom_scan_button:
                perform_custom_scan(malware_type_checkboxes, status_area)
            elif event.getSource() == execute_button:
                perform_malware_scan(malware_type_checkboxes, include_strings_checkbox, 
                                    include_apis_checkbox, include_behavior_checkbox, status_area)
    
    listener = ButtonActionListener()
    quick_scan_button.addActionListener(listener)
    full_scan_button.addActionListener(listener)
    custom_scan_button.addActionListener(listener)
    execute_button.addActionListener(listener)
    
    return panel


def create_behavior_analysis_panel():
    """Create panel for behavior analysis"""
    
    panel = JPanel(BorderLayout())
    panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10))
    
    # Behavior categories
    behavior_panel = JPanel(BorderLayout())
    behavior_panel.setBorder(BorderFactory.createTitledBorder("Behavior Analysis"))
    
    # Behavior list
    behavior_list_panel = JPanel(BorderLayout())
    behavior_label = JLabel("Suspicious Behaviors:")
    behavior_model = DefaultListModel()
    behavior_list = JList(behavior_model)
    behavior_list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION)
    behavior_scroll = JScrollPane(behavior_list)
    behavior_scroll.setPreferredSize(Dimension(400, 250))
    
    behavior_list_panel.add(behavior_label, BorderLayout.NORTH)
    behavior_list_panel.add(behavior_scroll, BorderLayout.CENTER)
    
    # Behavior details
    details_panel = JPanel(BorderLayout())
    details_label = JLabel("Behavior Details:")
    details_area = JTextArea()
    details_area.setEditable(False)
    details_area.setLineWrap(True)
    details_area.setWrapStyleWord(True)
    details_scroll = JScrollPane(details_area)
    details_scroll.setPreferredSize(Dimension(600, 250))
    
    details_panel.add(details_label, BorderLayout.NORTH)
    details_panel.add(details_scroll, BorderLayout.CENTER)
    
    # Execution options
    execution_panel = JPanel(FlowLayout(FlowLayout.LEFT))
    analyze_button = JButton("Analyze Behaviors")
    analyze_button.setPreferredSize(Dimension(150, 30))
    execution_panel.add(analyze_button)
    
    # Bottom panel with status
    bottom_panel = JPanel(BorderLayout())
    status_area = JTextArea()
    status_area.setEditable(False)
    status_area.setLineWrap(True)
    status_area.setWrapStyleWord(True)
    status_scroll = JScrollPane(status_area)
    status_scroll.setPreferredSize(Dimension(800, 100))
    
    bottom_panel.add(status_scroll, BorderLayout.CENTER)
    
    # Add components to panel
    panel.add(behavior_list_panel, BorderLayout.WEST)
    panel.add(details_panel, BorderLayout.CENTER)
    panel.add(execution_panel, BorderLayout.NORTH)
    panel.add(bottom_panel, BorderLayout.SOUTH)
    
    # Populate behaviors
    populate_behaviors(behavior_model)
    
    # Add action listeners
    class ButtonActionListener(ActionListener):
        def actionPerformed(self, event):
            if event.getSource() == analyze_button:
                analyze_behaviors(behavior_list, behavior_model, status_area)
    
    listener = ButtonActionListener()
    analyze_button.addActionListener(listener)
    
    # Add list selection listener
    class ListSelectionListener(ActionListener):
        def actionPerformed(self, event):
            selected_behavior = behavior_list.getSelectedValue()
            if selected_behavior:
                details_area.setText(get_behavior_description(selected_behavior))
    
    behavior_list.addListSelectionListener(
        lambda e: ListSelectionListener().actionPerformed(None) if not e.getValueIsAdjusting() else None
    )
    
    return panel


def create_signature_scanner_panel():
    """Create panel for signature scanning"""
    
    panel = JPanel(BorderLayout())
    panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10))
    
    # Signature database
    signature_panel = JPanel(BorderLayout())
    signature_panel.setBorder(BorderFactory.createTitledBorder("Signature Database"))
    
    # Signature list
    signature_list_panel = JPanel(BorderLayout())
    signature_label = JLabel("Malware Signatures:")
    signature_model = DefaultListModel()
    signature_list = JList(signature_model)
    signature_list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION)
    signature_scroll = JScrollPane(signature_list)
    signature_scroll.setPreferredSize(Dimension(400, 250))
    
    signature_list_panel.add(signature_label, BorderLayout.NORTH)
    signature_list_panel.add(signature_scroll, BorderLayout.CENTER)
    
    # Signature details
    details_panel = JPanel(BorderLayout())
    details_label = JLabel("Signature Details:")
    details_area = JTextArea()
    details_area.setEditable(False)
    details_area.setLineWrap(True)
    details_area.setWrapStyleWord(True)
    details_scroll = JScrollPane(details_area)
    details_scroll.setPreferredSize(Dimension(600, 250))
    
    details_panel.add(details_label, BorderLayout.NORTH)
    details_panel.add(details_scroll, BorderLayout.CENTER)
    
    # Custom signature
    custom_panel = JPanel(BorderLayout())
    custom_panel.setBorder(BorderFactory.createTitledBorder("Custom Signature"))
    
    custom_name_label = JLabel("Signature Name:")
    custom_name_text = JTextField()
    custom_pattern_label = JLabel("Pattern:")
    custom_pattern_text = JTextField()
    add_custom_button = JButton("Add Custom Signature")
    
    custom_grid = JPanel(GridLayout(3, 2))
    custom_grid.add(custom_name_label)
    custom_grid.add(custom_name_text)
    custom_grid.add(custom_pattern_label)
    custom_grid.add(custom_pattern_text)
    custom_grid.add(JLabel())
    custom_grid.add(add_custom_button)
    
    custom_panel.add(custom_grid, BorderLayout.CENTER)
    
    # Execution options
    execution_panel = JPanel(FlowLayout(FlowLayout.LEFT))
    scan_signatures_button = JButton("Scan Signatures")
    scan_signatures_button.setPreferredSize(Dimension(150, 30))
    execution_panel.add(scan_signatures_button)
    
    # Add components to panel
    panel.add(signature_list_panel, BorderLayout.WEST)
    panel.add(details_panel, BorderLayout.CENTER)
    panel.add(custom_panel, BorderLayout.SOUTH)
    panel.add(execution_panel, BorderLayout.NORTH)
    
    # Populate signatures
    populate_signatures(signature_model)
    
    # Add action listeners
    class ButtonActionListener(ActionListener):
        def actionPerformed(self, event):
            if event.getSource() == add_custom_button:
                add_custom_signature(custom_name_text, custom_pattern_text, signature_model, details_area)
            elif event.getSource() == scan_signatures_button:
                scan_signatures(signature_list, signature_model, details_area)
    
    listener = ButtonActionListener()
    add_custom_button.addActionListener(listener)
    scan_signatures_button.addActionListener(listener)
    
    # Add list selection listener
    class ListSelectionListener(ActionListener):
        def actionPerformed(self, event):
            selected_signature = signature_list.getSelectedValue()
            if selected_signature:
                details_area.setText(get_signature_description(selected_signature))
    
    signature_list.addListSelectionListener(
        lambda e: ListSelectionListener().actionPerformed(None) if not e.getValueIsAdjusting() else None
    )
    
    return panel


def create_api_usage_panel():
    """Create panel for API usage analysis"""
    
    panel = JPanel(BorderLayout())
    panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10))
    
    # API categories
    api_panel = JPanel(BorderLayout())
    api_panel.setBorder(BorderFactory.createTitledBorder("API Usage Analysis"))
    
    # API category list
    category_panel = JPanel(BorderLayout())
    category_label = JLabel("API Categories:")
    category_model = DefaultListModel()
    category_list = JList(category_model)
    category_list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION)
    category_scroll = JScrollPane(category_list)
    category_scroll.setPreferredSize(Dimension(200, 250))
    
    category_panel.add(category_label, BorderLayout.NORTH)
    category_panel.add(category_scroll, BorderLayout.CENTER)
    
    # API list
    api_list_panel = JPanel(BorderLayout())
    api_label = JLabel("APIs:")
    api_model = DefaultListModel()
    api_list = JList(api_model)
    api_list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION)
    api_scroll = JScrollPane(api_list)
    api_scroll.setPreferredSize(Dimension(300, 250))
    
    api_list_panel.add(api_label, BorderLayout.NORTH)
    api_list_panel.add(api_scroll, BorderLayout.CENTER)
    
    # API details
    details_panel = JPanel(BorderLayout())
    details_label = JLabel("API Details:")
    details_area = JTextArea()
    details_area.setEditable(False)
    details_area.setLineWrap(True)
    details_area.setWrapStyleWord(True)
    details_scroll = JScrollPane(details_area)
    details_scroll.setPreferredSize(Dimension(400, 250))
    
    details_panel.add(details_label, BorderLayout.NORTH)
    details_panel.add(details_scroll, BorderLayout.CENTER)
    
    # Execution options
    execution_panel = JPanel(FlowLayout(FlowLayout.LEFT))
    analyze_api_button = JButton("Analyze API Usage")
    analyze_api_button.setPreferredSize(Dimension(150, 30))
    execution_panel.add(analyze_api_button)
    
    # Bottom panel with status
    bottom_panel = JPanel(BorderLayout())
    status_area = JTextArea()
    status_area.setEditable(False)
    status_area.setLineWrap(True)
    status_area.setWrapStyleWord(True)
    status_scroll = JScrollPane(status_area)
    status_scroll.setPreferredSize(Dimension(800, 100))
    
    bottom_panel.add(status_scroll, BorderLayout.CENTER)
    
    # Add components to panel
    panel.add(category_panel, BorderLayout.WEST)
    panel.add(api_list_panel, BorderLayout.CENTER)
    panel.add(details_panel, BorderLayout.EAST)
    panel.add(execution_panel, BorderLayout.NORTH)
    panel.add(bottom_panel, BorderLayout.SOUTH)
    
    # Populate API categories
    populate_api_categories(category_model)
    
    # Add action listeners
    class ButtonActionListener(ActionListener):
        def actionPerformed(self, event):
            if event.getSource() == analyze_api_button:
                analyze_api_usage(api_list, api_model, status_area)
    
    listener = ButtonActionListener()
    analyze_api_button.addActionListener(listener)
    
    # Add category list selection listener
    class CategorySelectionListener(ActionListener):
        def actionPerformed(self, event):
            selected_category = category_list.getSelectedValue()
            if selected_category:
                populate_apis_for_category(selected_category, api_model)
    
    category_list.addListSelectionListener(
        lambda e: CategorySelectionListener().actionPerformed(None) if not e.getValueIsAdjusting() else None
    )
    
    # Add API list selection listener
    class ApiSelectionListener(ActionListener):
        def actionPerformed(self, event):
            selected_apis = api_list.getSelectedValuesList()
            if selected_apis:
                details = "Selected APIs:\n"
                for api in selected_apis:
                    details += f"- {api}\n"
                details_area.setText(details)
    
    api_list.addListSelectionListener(
        lambda e: ApiSelectionListener().actionPerformed(None) if not e.getValueIsAdjusting() else None
    )
    
    return panel


def create_malware_results_panel():
    """Create panel for malware analysis results"""
    
    panel = JPanel(BorderLayout())
    panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10))
    
    # Results table
    table_panel = JPanel(BorderLayout())
    table_label = JLabel("Malware Analysis Results:")
    table_model = DefaultTableModel(["Malware Type", "Confidence", "Signatures Found", "Behaviors Detected", "API Calls", "Actions"], 0)
    result_table = JTable(table_model)
    result_table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS)
    table_scroll = JScrollPane(result_table)
    table_scroll.setPreferredSize(Dimension(800, 200))
    
    table_panel.add(table_label, BorderLayout.NORTH)
    table_panel.add(table_scroll, BorderLayout.CENTER)
    
    # Results details
    details_panel = JPanel(BorderLayout())
    details_label = JLabel("Result Details:")
    details_area = JTextArea()
    details_area.setEditable(False)
    details_area.setLineWrap(True)
    details_area.setWrapStyleWord(True)
    details_scroll = JScrollPane(details_area)
    details_scroll.setPreferredSize(Dimension(800, 200))
    
    details_panel.add(details_label, BorderLayout.NORTH)
    details_panel.add(details_scroll, BorderLayout.CENTER)
    
    # Action buttons
    action_panel = JPanel(FlowLayout(FlowLayout.LEFT))
    export_button = JButton("Export Results")
    clear_button = JButton("Clear Results")
    generate_report_button = JButton("Generate Report")
    action_panel.add(export_button)
    action_panel.add(clear_button)
    action_panel.add(generate_report_button)
    
    # Add components to panel
    panel.add(table_panel, BorderLayout.NORTH)
    panel.add(details_panel, BorderLayout.CENTER)
    panel.add(action_panel, BorderLayout.SOUTH)
    
    # Add action listeners
    class ButtonActionListener(ActionListener):
        def actionPerformed(self, event):
            if event.getSource() == export_button:
                export_malware_results(table_model, details_area)
            elif event.getSource() == clear_button:
                clear_malware_results(table_model, details_area)
            elif event.getSource() == generate_report_button:
                generate_malware_report(table_model, details_area)
    
    listener = ButtonActionListener()
    export_button.addActionListener(listener)
    clear_button.addActionListener(listener)
    generate_report_button.addActionListener(listener)
    
    # Add table selection listener
    class TableSelectionListener(ActionListener):
        def actionPerformed(self, event):
            selected_row = result_table.getSelectedRow()
            if selected_row >= 0:
                malware_type = table_model.getValueAt(selected_row, 0)
                confidence = table_model.getValueAt(selected_row, 1)
                signatures = table_model.getValueAt(selected_row, 2)
                behaviors = table_model.getValueAt(selected_row, 3)
                api_calls = table_model.getValueAt(selected_row, 4)
                details_area.setText(f"Malware Type: {malware_type}\nConfidence: {confidence}\nSignatures Found: {signatures}\nBehaviors Detected: {behaviors}\nAPI Calls: {api_calls}")
    
    result_table.getSelectionModel().addListSelectionListener(
        lambda e: TableSelectionListener().actionPerformed(None) if not e.getValueIsAdjusting() else None
    )
    
    return panel


def perform_quick_scan(malware_type_checkboxes, status_area):
    """Perform quick malware scan"""
    try:
        if not currentProgram:
            status_area.setText("No program open for analysis")
            return
        
        status_area.setText("Performing quick malware scan...")
        
        # Get selected malware types
        selected_types = []
        for malware_type, checkbox in malware_type_checkboxes.items():
            if checkbox.isSelected():
                selected_types.append(malware_type)
        
        if not selected_types:
            status_area.setText("No malware types selected for scan")
            return
        
        # Simulate quick scan
        time.sleep(2)
        
        status_area.append("\nQuick scan completed!")
        status_area.append("\nPotential malware types detected:")
        status_area.append("\n- Ransomware (Low Confidence)")
        status_area.append("\n- Trojan (Medium Confidence)")
        
    except Exception as e:
        status_area.setText(f"Error performing quick scan: {e}")


def perform_full_scan(malware_type_checkboxes, status_area):
    """Perform full malware scan"""
    try:
        if not currentProgram:
            status_area.setText("No program open for analysis")
            return
        
        status_area.setText("Performing full malware scan...")
        
        # Get selected malware types
        selected_types = []
        for malware_type, checkbox in malware_type_checkboxes.items():
            if checkbox.isSelected():
                selected_types.append(malware_type)
        
        if not selected_types:
            status_area.setText("No malware types selected for scan")
            return
        
        # Simulate full scan
        time.sleep(5)
        
        status_area.append("\nFull scan completed!")
        status_area.append("\nDetailed analysis results:")
        status_area.append("\n- Trojan Horse (High Confidence)")
        status_area.append("\n  - Found suspicious network APIs")
        status_area.append("\n  - Detected potential backdoor behavior")
        status_area.append("\n- Ransomware (Low Confidence)")
        status_area.append("\n  - Found encryption-related functions")
        
    except Exception as e:
        status_area.setText(f"Error performing full scan: {e}")


def perform_custom_scan(malware_type_checkboxes, status_area):
    """Perform custom malware scan"""
    try:
        if not currentProgram:
            status_area.setText("No program open for analysis")
            return
        
        status_area.setText("Performing custom malware scan...")
        
        # Get selected malware types
        selected_types = []
        for malware_type, checkbox in malware_type_checkboxes.items():
            if checkbox.isSelected():
                selected_types.append(malware_type)
        
        if not selected_types:
            status_area.setText("No malware types selected for scan")
            return
        
        # Simulate custom scan
        time.sleep(3)
        
        status_area.append("\nCustom scan completed!")
        status_area.append("\nCustom analysis results:")
        status_area.append("\n- Selected malware types: " + ", ".join(selected_types))
        status_area.append("\n- No suspicious activity detected")
        
    except Exception as e:
        status_area.setText(f"Error performing custom scan: {e}")


def perform_malware_scan(malware_type_checkboxes, include_strings_checkbox, 
                       include_apis_checkbox, include_behavior_checkbox, status_area):
    """Perform comprehensive malware scan"""
    try:
        if not currentProgram:
            status_area.setText("No program open for analysis")
            return
        
        status_area.setText("Performing comprehensive malware scan...")
        
        # Get selected malware types
        selected_types = []
        for malware_type, checkbox in malware_type_checkboxes.items():
            if checkbox.isSelected():
                selected_types.append(malware_type)
        
        if not selected_types:
            status_area.setText("No malware types selected for scan")
            return
        
        # Get scan options
        include_strings = include_strings_checkbox.isSelected()
        include_apis = include_apis_checkbox.isSelected()
        include_behavior = include_behavior_checkbox.isSelected()
        
        # Simulate comprehensive scan
        time.sleep(4)
        
        status_area.append("\nComprehensive scan completed!")
        status_area.append("\nDetailed analysis results:")
        status_area.append("\n- Scan options:")
        status_area.append(f"\n  - String analysis: {'Enabled' if include_strings else 'Disabled'}")
        status_area.append(f"\n  - API analysis: {'Enabled' if include_apis else 'Disabled'}")
        status_area.append(f"\n  - Behavior analysis: {'Enabled' if include_behavior else 'Disabled'}")
        status_area.append("\n- Potential threats:")
        status_area.append("\n  - Trojan Horse (High Confidence)")
        status_area.append("\n    * Found suspicious network APIs")
        status_area.append("\n    * Detected potential backdoor behavior")
        status_area.append("\n  - Spyware (Medium Confidence)")
        status_area.append("\n    * Found keylogging-related strings")
        status_area.append("\n    * Detected screen capture APIs")
        
    except Exception as e:
        status_area.setText(f"Error performing malware scan: {e}")


def populate_behaviors(model):
    """Populate behaviors list"""
    behaviors = [
        "file_encryption", "ransom_note", "wallet_address", "network_connection",
        "remote_access", "command_execution", "file_download", "persistence",
        "self_replication", "file_infection", "boot_sector_modification",
        "network_scanning", "self_propagation", "remote_exploitation",
        "keylogging", "screen_capture", "data_exfiltration", "password_stealing",
        "unwanted_ads", "browser_redirect", "click_fraud",
        "privilege_escalation", "process_hiding", "file_hiding",
        "c2_communication", "remote_control", "ddos_attack", "spam",
        "vulnerability_exploitation", "code_injection"
    ]
    
    for behavior in behaviors:
        model.addElement(behavior)


def get_behavior_description(behavior):
    """Get description for a behavior"""
    descriptions = {
        "file_encryption": "Encrypts files on the system",
        "ransom_note": "Creates a ransom note demanding payment",
        "wallet_address": "Contains cryptocurrency wallet addresses",
        "network_connection": "Establishes network connections",
        "remote_access": "Provides remote access to the system",
        "command_execution": "Executes arbitrary commands",
        "file_download": "Downloads files from the internet",
        "persistence": "Maintains persistence on the system",
        "self_replication": "Replicates itself",
        "file_infection": "Infects other files",
        "boot_sector_modification": "Modifies boot sectors",
        "network_scanning": "Scans for network vulnerabilities",
        "self_propagation": "Spreads to other systems",
        "remote_exploitation": "Exploits remote vulnerabilities",
        "keylogging": "Records keystrokes",
        "screen_capture": "Captures screenshots",
        "data_exfiltration": "Exfiltrates data",
        "password_stealing": "Steals passwords",
        "unwanted_ads": "Displays unwanted advertisements",
        "browser_redirect": "Redirects browser traffic",
        "click_fraud": "Engages in click fraud",
        "privilege_escalation": "Escalates privileges",
        "process_hiding": "Hides processes",
        "file_hiding": "Hides files",
        "c2_communication": "Communicates with command and control servers",
        "remote_control": "Allows remote control of the system",
        "ddos_attack": "Launches DDoS attacks",
        "spam": "Sends spam emails",
        "vulnerability_exploitation": "Exploits system vulnerabilities",
        "code_injection": "Injects malicious code"
    }
    return descriptions.get(behavior, "No description available")


def analyze_behaviors(behavior_list, behavior_model, status_area):
    """Analyze behaviors"""
    try:
        if not currentProgram:
            status_area.setText("No program open for analysis")
            return
        
        # Get selected behaviors
        selected_behaviors = []
        selected_indices = behavior_list.getSelectedIndices()
        for index in selected_indices:
            selected_behaviors.append(behavior_model.getElementAt(index))
        
        if not selected_behaviors:
            status_area.setText("No behaviors selected for analysis")
            return
        
        status_area.setText(f"Analyzing {len(selected_behaviors)} behaviors...")
        
        # Simulate behavior analysis
        time.sleep(2)
        
        status_area.append("\nBehavior analysis completed!")
        status_area.append("\nAnalysis results:")
        for behavior in selected_behaviors:
            status_area.append(f"\n- {behavior}: Not detected")
        
    except Exception as e:
        status_area.setText(f"Error analyzing behaviors: {e}")


def populate_signatures(model):
    """Populate signatures list"""
    for malware_type, info in MALWARE_SIGNATURES.items():
        model.addElement(f"{info['name']} signatures")


def get_signature_description(signature):
    """Get description for a signature"""
    for malware_type, info in MALWARE_SIGNATURES.items():
        if f"{info['name']} signatures" == signature:
            return f"{info['description']}\n\nSignatures:\n" + "\n".join([f"- {sig}" for sig in info['signatures']])
    return "No description available"


def add_custom_signature(name_text, pattern_text, model, details_area):
    """Add custom signature"""
    try:
        name = name_text.getText().strip()
        pattern = pattern_text.getText().strip()
        
        if not name or not pattern:
            details_area.setText("Please enter both name and pattern for custom signature")
            return
        
        model.addElement(f"Custom: {name}")
        name_text.setText("")
        pattern_text.setText("")
        details_area.setText(f"Added custom signature: {name}")
        
    except Exception as e:
        details_area.setText(f"Error adding custom signature: {e}")


def scan_signatures(signature_list, signature_model, details_area):
    """Scan signatures"""
    try:
        if not currentProgram:
            details_area.setText("No program open for analysis")
            return
        
        # Get selected signatures
        selected_signatures = []
        selected_indices = signature_list.getSelectedIndices()
        for index in selected_indices:
            selected_signatures.append(signature_model.getElementAt(index))
        
        if not selected_signatures:
            details_area.setText("No signatures selected for scanning")
            return
        
        details_area.setText(f"Scanning {len(selected_signatures)} signatures...")
        
        # Simulate signature scanning
        time.sleep(2)
        
        details_area.append("\nSignature scanning completed!")
        details_area.append("\nScan results:")
        for signature in selected_signatures:
            details_area.append(f"\n- {signature}: No matches found")
        
    except Exception as e:
        details_area.setText(f"Error scanning signatures: {e}")


def populate_api_categories(model):
    """Populate API categories"""
    for category in SUSPICIOUS_APIS.keys():
        model.addElement(category)


def populate_apis_for_category(category, model):
    """Populate APIs for selected category"""
    model.clear()
    apis = SUSPICIOUS_APIS.get(category, [])
    for api in apis:
        model.addElement(api)


def analyze_api_usage(api_list, api_model, status_area):
    """Analyze API usage"""
    try:
        if not currentProgram:
            status_area.setText("No program open for analysis")
            return
        
        # Get selected APIs
        selected_apis = []
        selected_indices = api_list.getSelectedIndices()
        for index in selected_indices:
            selected_apis.append(api_model.getElementAt(index))
        
        if not selected_apis:
            status_area.setText("No APIs selected for analysis")
            return
        
        status_area.setText(f"Analyzing usage of {len(selected_apis)} APIs...")
        
        # Simulate API usage analysis
        time.sleep(2)
        
        status_area.append("\nAPI usage analysis completed!")
        status_area.append("\nAnalysis results:")
        for api in selected_apis:
            status_area.append(f"\n- {api}: Not used")
        
    except Exception as e:
        status_area.setText(f"Error analyzing API usage: {e}")


def export_malware_results(table_model, details_area):
    """Export malware analysis results"""
    try:
        if table_model.getRowCount() == 0:
            details_area.setText("No results to export")
            return
        
        # Show file chooser
        chooser = JFileChooser()
        chooser.setDialogTitle("Export Malware Analysis Results")
        chooser.setFileSelectionMode(JFileChooser.FILES_ONLY)
        chooser.setFileFilter(FileNameExtensionFilter("CSV files (*.csv)", "csv"))
        
        if chooser.showSaveDialog(None) == JFileChooser.APPROVE_OPTION:
            file = chooser.getSelectedFile()
            file_path = file.getAbsolutePath()
            if not file_path.endswith(".csv"):
                file_path += ".csv"
            
            # Export results to CSV
            with open(file_path, 'w') as f:
                # Write header
                header = ",".join([table_model.getColumnName(i) for i in range(table_model.getColumnCount())])
                f.write(header + "\n")
                
                # Write rows
                for i in range(table_model.getRowCount()):
                    row = ",".join([str(table_model.getValueAt(i, j)) for j in range(table_model.getColumnCount())])
                    f.write(row + "\n")
            
            details_area.setText(f"Results exported successfully to {file_path}")
        else:
            details_area.setText("Results export cancelled")
            
    except Exception as e:
        details_area.setText(f"Error exporting results: {e}")


def clear_malware_results(table_model, details_area):
    """Clear malware analysis results"""
    try:
        table_model.setRowCount(0)
        details_area.setText("Results cleared successfully")
        
    except Exception as e:
        details_area.setText(f"Error clearing results: {e}")


def generate_malware_report(table_model, details_area):
    """Generate malware analysis report"""
    try:
        if table_model.getRowCount() == 0:
            details_area.setText("No results to generate report")
            return
        
        details_area.setText("Generating malware analysis report...")
        
        # Simulate report generation
        time.sleep(2)
        
        report = "MALWARE ANALYSIS REPORT\n"
        report += "==========================\n\n"
        report += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        report += f"Program: {currentProgram.name if currentProgram else 'Unknown'}\n\n"
        report += "ANALYSIS RESULTS:\n"
        report += "-----------------\n"
        
        for i in range(table_model.getRowCount()):
            malware_type = table_model.getValueAt(i, 0)
            confidence = table_model.getValueAt(i, 1)
            report += f"- {malware_type}: {confidence}\n"
        
        report += "\nCONCLUSION:\n"
        report += "-----------\n"
        report += "No malware detected.\n"
        
        details_area.setText(report)
        
    except Exception as e:
        details_area.setText(f"Error generating report: {e}")


# Run the malware analyzer
if __name__ == "__main__":
    show_malware_analyzer()